# –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ HTTP -> HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ecos-vsu.ru www.ecos-vsu.ru;
    return 301 https://$host$request_uri;
}

# HTTPS-—Å–µ—Ä–≤–µ—Ä
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name ecos-vsu.ru www.ecos-vsu.ru;

    ignore_invalid_headers off;
    
    ssl_certificate /etc/letsencrypt/live/ecos-vsu.ru/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/ecos-vsu.ru/privkey.pem;

    # –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SSL (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å)
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    root /var/www/html;
    index index.html index.nginx-debian.html;


    # üîÅ –ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ Keycloak
    location /auth/ {
        proxy_pass http://keycloak;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # üîÅ –ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ MinIO API
    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
        chunked_transfer_encoding off;

        proxy_pass http://minio_s3;
    }

    # üîÅ –ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ MinIO Console
    location /minio/ui/ {
      rewrite ^/minio/ui/(.*) /$1 break;

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-NginX-Proxy true;

      real_ip_header X-Real-IP;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      
      proxy_pass http://minio_console;
    }
    
    # üîÅ –ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ backend API
    location /api/v1/ {
    access_by_lua_block {
        local function normalize_path(uri)
            local function split_string(str, delim)
                local result = {}
                for match in (str .. delim):gmatch("(.-)" .. delim) do
                    table.insert(result, match)
                end
                return result
            end

            local function is_uuid(str)
                ngx.log(ngx.DEBUG, str:match("%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x"))
                return str:match("%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x") ~= nil
            end

            local function is_str_64(str)
                ngx.log(ngx.DEBUG, str:match("%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"))
                return str:match("%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x") ~= nil
            end

            local function clean_path(parts)
                local result = {}
                for _, part in ipairs(parts) do
                    if part ~= "" then
                        table.insert(result, part)
                    end
                end
                return result
            end

            ngx.log(ngx.DEBUG, "Original URI: ", uri)
            ngx.log(ngx.DEBUG, "Original Request URI: ", ngx.var.request_uri)

            local parts = clean_path(split_string(uri:sub(2), "/"))
            ngx.log(ngx.DEBUG, "Split and cleaned parts: ", require("cjson").encode(parts))

            local normalized = {}

            for _, part in ipairs(parts) do
                ngx.log(ngx.DEBUG, "FOR BLOCK: ", part)
                if part ~= "" then
                    if is_uuid(part) then
                        ngx.log(ngx.DEBUG, "Detected UUID part, replacing with '*': ", part)
                        table.insert(normalized, "*")
                    elseif is_str_64(part) then
                        ngx.log(ngx.DEBUG, "Detected 64-character part, replacing with '*': ", part)
                        table.insert(normalized, "*")
                    else
                        table.insert(normalized, part)
                    end
                end
            end

            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏–µ –Ω–∞ / –∏–ª–∏ /?
            if ngx.var.request_uri:match("/$") or ngx.var.request_uri:match("/%?$") then
                ngx.log(ngx.DEBUG, "Request URI ends with '/' or '/?', appending '*'")
                table.insert(normalized, "*")
            end

            ngx.log(ngx.DEBUG, "Normalized path: ", require("cjson").encode(normalized))

            return normalized
        end

        -- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
        local cjson = require "cjson"
        local base64 = require "ngx.base64"
        local http = require "resty.http"
        local roles = {""}  -- –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—É—Å—Ç—ã–µ —Ä–æ–ª–∏

        -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ Authorization header
        local auth_header = ngx.var.http_Authorization
        
        if auth_header then
            -- –ò–∑–≤–ª–µ–∫–∞–µ–º JWT —Ç–æ–∫–µ–Ω (—É—á–∏—Ç—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã)
            local jwt_token = auth_header:match("^[Bb]earer%s+(.+)$")
            if jwt_token then
                ngx.log(ngx.DEBUG, "JWT token: ", jwt_token)

                -- –î–µ–∫–æ–¥–∏—Ä—É–µ–º JWT (—Ç–æ–ª—å–∫–æ payload —á–∞—Å—Ç—å)
                local jwt_parts = {}
                for part in jwt_token:gmatch("[^.]+") do
                    table.insert(jwt_parts, part)
                end

                if #jwt_parts == 3 then
                    local payload_b64 = jwt_parts[2]
                    ngx.log(ngx.DEBUG, "Payload base64: ", payload_b64)

                    -- –î–æ–±–∞–≤–ª—è–µ–º padding, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
                    local pad = #payload_b64 % 4
                    if pad > 0 then
                        payload_b64 = payload_b64 .. string.rep("=", 4 - pad)
                    end

                    local payload_json, err = base64.decode_base64url(payload_b64)
                    if payload_json then
                        ngx.log(ngx.DEBUG, "Payload JSON: ", payload_json)
                        
                        local payload = cjson.decode(payload_json)
                        if payload then
                            -- –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–æ–ª–∏ –∏–∑ —Ç–æ–∫–µ–Ω–∞
                            if payload.realm_access and payload.realm_access.roles then
                                roles = payload.realm_access.roles
                            end
                        else
                            ngx.log(ngx.WARN, "Failed to parse JWT payload: ", err)
                        end
                    else
                        ngx.log(ngx.WARN, "Failed to decode JWT payload: ", err)
                    end
                else
                    ngx.log(ngx.WARN, "Invalid JWT format, parts count: ", #jwt_parts)
                end
            else
                ngx.log(ngx.WARN, "Invalid Authorization header format")
            end
        else
            ngx.log(ngx.DEBUG, "No Authorization header provided, using empty roles")
        end

        ngx.log(ngx.DEBUG, "User roles: ", cjson.encode(roles))

        -- –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ OPA
        local httpc = http.new()
        local res, err = httpc:request_uri("http://127.0.0.1:8181/v1/data/test/allow", {
            method = "POST",
            body = cjson.encode({
                input = {
                    method = ngx.req.get_method(),
                    path = normalize_path(ngx.var.uri),
                    roles = roles
                }
            }),
            headers = {
                ["Content-Type"] = "application/json"
            }
        })

        if not res then
            ngx.log(ngx.ERR, "OPA request failed: ", err)
            return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        end

        ngx.log(ngx.DEBUG, "OPA response: ", res.body)

        local decoded = cjson.decode(res.body)
        if decoded.result and decoded.result == true then
            -- —Ä–∞–∑—Ä–µ—à–µ–Ω–æ ‚Äî –ø—Ä–æ–∫—Å–∏—Ä—É–µ–º –¥–∞–ª—å—à–µ
            return
        else
            ngx.log(ngx.ERR, "Access denied by OPA for roles: ", cjson.encode(roles))
            return ngx.exit(ngx.HTTP_FORBIDDEN)
        end
    }

    proxy_pass http://ecos;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    }    
}
